import asset from 'next/asset'
import { withDoc } from 'app/lib'
import { Alert, Tip, Info } from 'app/components'

export const meta = {
  title: 'Band framework API',
}

<h1 id="doc-h1">
  {meta.title}
</h1>

```python
from band import settings, logger, expose, worker, cleanup, response, rpc, scheduler
```

## band.response

`return response.redirect(location)`

`return response.data(data)`

`return response.error(message)`

`return response.pixel()`

<Tip>
  Work in progress
</Tip>

## band.expose

Анонсирование методов и предоставление доступа к ним. Анонсирование производится в сервис `front`, 
где обрабатывается жизненный цикл входящих запросов [подробне](/docs/architecture/request-lifecycle).
Изначально все методы являются внутренними, но к ним может быть открыт доступ по RPC и HTTP 
(доступен извне только в особых случаях).

### expose / предоставление доступа к методу

`@expose()`

Сделать метод доступным другим сервисам, но при этом не анонсировать.
Обращаться к этому методу можно будет по имени и названию сервиса. 
Сервис `front` ничего не узнает о нем и не будет прокидвать запросы снаружи.

```python
from band import expose

@expose()
async def main(**params):
    print(params)
```

### expose.enricher / регистрация обогатителем

`expose.enricher(props: dict, keys: list)`

Arguments:
- **props**: список интересующих параметеров входящих сообщений
- **keys**: список ключей маршрутизации которые будут обрабатываться. 
  В данный момент устройство таково, что приходить будут все сообщения, 
  но указывать необходимо, чтобы сервис `front` знал, кто ему должен ответить на ключ.

Метод будет зарегистрирован в `front` service. 

Метод обязательно должен называться `enrich`.

```python
from band import expose

@expose.enricher(props={'ip': 'td.ip', 'ua': 'td.ua', 'uid': 'uid'}, ['in.gen.track']})
async def enrich(ip, ua, uid, **params):
    print(ip, ua, uid, params)
    return {'param1': 'value1'}
```
Возвращенное значение будет добавлено к входящему запросу. Ключом будет имя сервиса.
После выполнения всех `enrichers` запрос будет передан в `handler`, а затем всем `listener`-ам.

В следующем примере фигурирует результат 4 обогатителей: `uaparser`, `mmgeo`, `sxgeo`, `fpid`.

```json
{ 
  "key": "in.gen.track.page", 
  "service": "track", 
  "name": "page",
  //....
  "uid": "6450101900745375744", 
  "data": { 
    "service": "track", 
    "name": "page", 
    "uid": "6450101900745375744", 
    "page": { "title": "ODL Shop", "ref": "https://app.test.rstat.org/logs", ... }, 
    "sess": { "pageNum": 1, "eventNum": 0, "type": "referral", "marks": {}, ... }, 
    //...
    "uaparser": { "os_family": "Mac OS X", "os_version": [ 10, 13, 6 ], ... }, 
    "mmgeo": { "country_en": "Russia", "country_ru": "Россия", ... }, 
    "sxgeo": { "country_en": "United Kingdom", "country_ru": "Великобритания", ... },
    "fpid": "14290956575723105017",
    "id": "6462522520963645440", 
  }
```



### expose.handler / регистрация обработчиком

`expose.handler(name=None, path=None, alias=None, timeout=None)`

Arguments:
- **name**: уточнить имя под которым будет доступен метод. Возможна **wildscard** регистрация. Делается это путем установки `name='*'`.
- **path**: уточнить http путь, можно использовать параметр, например `/mymethod/:id`. По http доступны только системные сервисы.
- **alias**: псевдомним сервиса. С его помощью можно зарегистрироваться и получать запросы под другим именем.
- **timeout**: сколько времени `front` service будет ждать ответа от этого метода. По умолчанию 200ms (1/5 секунды).

Метод будет зарегистрирован в `front` service. Запросы с совпадающим именем сервиса будут направлены на него. Возвращаемое значение будет возвращено наружу.


```python
from band import expose

@expose.handler()
async def my_method(**params):
    pass
```

с wildcard

```python
from band import expose

# method accessible on https://your.domain/go/*any_key*
@expose.handler(alias='go', name='*')
async def wildcard(name, **params):
    url = state.urls.get(name, None)
    return response.redirect(url) if url else response.error('Key not found')
```

### expose.listener / регистрация слушателем

`expose.listener()`

Метод будет зарегистрирован в `front` service. Попадут все сообщения на финальной стадии обработки. Метод обязательно должен называться `broadcast`. Возвращаемое значение не учитывается.

```python
from band import expose

@expose.listener()
async def broadcast(**params):
    pass
```

## band.worker / выполнение фоновых задач

`@worker()`

Метод будет запущен при старте приложения и будет синхронно выполдняться до тех пор, пока не завершится. Чтобы метод работал посстоянно используйте бесконечный цикл. Крайне желательно ставить паузу между циклами. 

```python
from band import worker

@worker()
async def do_job(**params):
    while True:
        state.counter += 1
        await asyncio.sleep(10)
```

Продвинутый пример

```python
from itertools import count
from band import expose

@worker()
async def service_worker():
    for num in count():
        # Обрабатываем ошибки, избегая падения
        try:
            # Перовый проход цикла для инициализации
            if num == 0:
                state.loaded = True
                # ...
            # Код выполняющийся каждый цикл
            state.loop = num
            # ...
        except asyncio.CancelledError:
            # Обработка остановки
            break
        except Exception:
            # Другие исключения
            logger.exception('my service exeption')
        # Ждем 5 секунд перед следующим проходом
        await asyncio.sleep(5)
```


## band.cleanup / обработка остановки

`@cleanup()`

Метод будет заапущен при остановке сервиса. Никаких тяжелых операций выполнять нельзя.
На выполнение дается 1/10 секунды, после чего метод будет насильно завершен.

```python
from band import cleanup

@cleanup()
async def service_cleanup():
    # Операции, которые будут выполнены при остановке сервиса
    state.loaded = False
```

## band.rpc / взимодействие с другими сервисами

`await rpc.request(service, name, param1='value1', param2='value2')`

<Tip>
  Work in progress
</Tip>

## band.scheduler / отделение выполнение задач

`await scheduler.spawn(coro)`

<Tip>
  Work in progress
</Tip>

## band.logger / логи

```python
from band import logger

uid = '12312321312'

logger.debug('message', data={'user': uid})
```

другие методы

```python
logger.debug('message')
logger.info('message')
logger.warn('message')
logger.error('message')
logger.exception('message') # будет показан stack trace
```

Для поддержки логов с параметрами используются `structlog` и `python-json-logger`.
Формат логов зависит от значения переменной `JSON_LOGS`.

## band.settings / настройки сервиса

Справочник содержащий данные из `config.yml`, при обработке конфига поставляются переменные откружения, 
как систеемные, так и пользовательсткие.

```yaml
# config.yml
pool:
  - 74994031705
  - 74994040139
  - 74994040921
  - 74994033095
  - 74994040239
extra:
  - 74994041156
# Подстановка переменной окружения API_KEY
api_key: "{{API_KEY}}"
```

В коде сервиса

```python
# main.py
from band import settings

print(settings.extra)

['74994041156']
```



export default withDoc({...meta})(({children}) => <>{children}</>)

